---
title: 链表环问题
tags:
  - 链表
  - 环形问题
  - 快慢指针
  - 指针法
categories:
  - 算法与数据结构
cover: >-
  https://images.pexels.com/photos/1025469/pexels-photo-1025469.jpeg?auto=compress&cs=tinysrgb&dpr=2&w=500
abbrlink: 3fa2e0b5
date: 2022-04-08 17:10:00
---

## 1. 判断链表是否有环
- [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

### 解法一 哈希表
- 将遍历过的节点存入哈希表，利用哈希表数据唯一性
```java
 /**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        Set<ListNode> s = new HashSet<>();
        while(head != null){
            if(!s.add(head)) return true;
            head = head.next;
        }
        return false;
    }
}
```

### 解法二(最优解) 快慢指针
- 此解法空间复杂度O(1)， 时间复杂度O(n)
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode slowPointer = head;
        ListNode fastPointer = head.next;
        while(slowPointer != fastPointer){
            if(fastPointer == null || fastPointer.next == null) //这里只需判断fastPointer
                return false;
            slowPointer = slowPointer.next;
            fastPointer = fastPointer.next.next;
        }
        return true;
    }
}
```

## 2. 获取环的入口节点
- [剑指 Offer II 022. 链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)
### 题解参考
- [题解](https://leetcode-cn.com/problems/c32eOV/solution/jian-zhi-offer-ii-022-lian-biao-zhong-hu-8f1m/)
### Java实现
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null) return null;
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow) {//判断出链表有环，快指针放到链表开始，然后快慢指针同速度前进
                fast = head;
                while(slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                return fast;
            }
        }
        return null;
    }
}
```


## 3. 计算环的长度 todo
- 在解决前两个问题的基础上，此问题变得很简单了
- [参考文章](https://blog.csdn.net/yuiop123455/article/details/108974001)


## 为什么快慢指针一定会相遇？
- [快慢指针慢指针和快指针一定会相遇](https://blog.csdn.net/Leslie5205912/article/details/89386769)