---
title: 二分查找及其变形
tags:
  - 查找
  - 二分法
categories: 算法与数据结构
abbrlink: 58043ebd
date: 2022-04-17 20:40:47
cover: https://images.pexels.com/photos/631477/pexels-photo-631477.jpeg?auto=compress&cs=tinysrgb&dpr=2&w=500
---

# Java实现
```java
public class BinarySearch {
    public static void main(String[] args) {
        int[] array = new int[]{1, 3, 5, 7, 9, 11, 19};
//        System.out.println(binarySearch(array, 19));
        System.out.println(binarySearchGE(array, 2));
//        System.out.println(binarySearchLE(array, 0));
    }

    public static int binarySearch(int[] arr, int k) {
        int f = 0, b = arr.length - 1, mid;
        while (f <= b) {
            mid = f + (b - f) / 2;//这样计算可以防止数据溢出
            if (k == arr[mid]) return mid;
            if (k < arr[mid]) b = mid - 1;
            else if (k > arr[mid]) f = mid + 1;
        }
        return -1;
    }

    /**
     * 查找第一个>=目标值的数 注意，目标数不一定出现在数组中
     * 这样好理解多了
     */
    private static int searchGE(int[] arr, int k){
        int f = 0, b = arr.length - 1, mid = 0;
        while (f <= b) {
            mid = f + (b - f) / 2;//这样计算可以防止数据溢出
            if (k == arr[mid]) return mid;
            if (k < arr[mid]) b = mid - 1;
            else if (k > arr[mid]) f = mid + 1;
        }
        System.out.println(f + ": " + b + ": " + mid);
        if (k < arr[0]) return 0;
        else if(mid + 1 < arr.length) return mid + 1;
        else return -1;
    }

    /**
     * 查找第一个>=目标值的数 注意，目标数不一定出现在数组中
     */
    public static int binarySearchGE(int[] arr, int target){
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            System.out.println(left + " " + mid + " " + right);
            if (target > arr[mid]) left = mid + 1;//如果是查第一个>目标值的数，只需要改成target >= arr[mid]
            else right = mid - 1;
        }
        if (left > arr.length - 1) return -1;
        return left;
    }

    /**
     * 查找第一个<=目标值的数 注意，目标数不一定出现在数组中
     */
    public static int binarySearchLE(int[] arr, int target){
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            System.out.println(left + " " + mid + " " + right);
            if (target < arr[mid]) right = mid - 1;//如果是查第一个<目标值的数，只需要改成target <= arr[mid]
            else left = mid + 1;
        }
        return right;
    }
}

```