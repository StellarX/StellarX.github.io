---
title: 重建二叉树
tags:
  - 二叉树
  - 递归
  - leetcode
categories:
  - 算法与数据结构
abbrlink: 97fc4ab0
date: 2022-04-27 18:20:06
cover:
---



## 题目

[重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

## 思路

- 用递归
- `int root_index_inorder = inMap.get(pre[root]);` //取出在中序的index
- `node.left = recur(root + 1, in_left, root_index_inorder - 1);`
  - 左子树先序序列中的根的索引、中序序列的左端、中序序列的右端
- `node.right = recur(root + 1 + root_index_inorder - in_left, root_index_inorder + 1, in_right);`
  - 左子树长度 + 根节点索引 + 1
  - 其中左子树长度 = **root_index_inorder - in_left**
  - 记住要加1，写个数组看看就知道为什么了



## Java实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int[] pre;
    private HashMap<Integer, Integer> inMap = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        pre = preorder;
        for(int i = 0; i < inorder.length; ++i) inMap.put(inorder[i], i);
        return recur(0, 0, inorder.length - 1);
    }
    private TreeNode recur(int root, int in_left, int in_right){
        //子树的先序根、中序开始、中序结束 下标
        if(in_left > in_right) return null;
        TreeNode node = new TreeNode(pre[root]);
        int root_index_inorder = inMap.get(pre[root]);
        node.left = recur(root + 1, in_left, root_index_inorder - 1);
        node.right = recur(root + 1 + root_index_inorder - in_left, root_index_inorder + 1, in_right);
        return node;
    }
}
```

