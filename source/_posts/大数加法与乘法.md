---
title: 大数加法与乘法
tags:
  - 大数
categories:
  - 算法与数据结构
abbrlink: 6c650022
date: 2022-05-21 16:17:01
cover: https://images.pexels.com/photos/2953902/pexels-photo-2953902.jpeg?auto=compress&cs=tinysrgb&dpr=2&w=500
---

# 大数相加

## 题目

- 两个很大很大的数，无法直接用现有的数据类型存储，如何求它们的和？

## 分析

- 模拟`竖式计算`（小学都学过），将大数`按位`拆分，并分别存储到一个数组中（`低位在前`，高位在后）
- 然后开始计算，将结果存到result数组中，注意进位
- 算完之后再逆序输出result数组即可得到答案

---

优化：
- 其实可以不用按位拆分，只需要拆分到可以被直接计算的程度就够了，比如int类型最多可以保存10位，那么可以按照9位为一个基本单元进行拆分，也就是每9位作为数组的一个元素
- 这样的话，空间占用和运算次数，都被压缩了9倍
- Java中的BigInteger和BigDecimal的底层就是这样的拆分思想

## Java实现
```java
    public static String bigNumberSum(String bigNumberA, String bigNumberB) {
        int maxLength = Math.max(bigNumberA.length(), bigNumberB.length());
        int[] arrayA = new int[maxLength + 1];
        int[] arrayB = new int[maxLength + 1];
        int[] result = new int[maxLength + 1];//构建result数组，数组长度等于较大整数位数+1
        for (int i = 0; i < bigNumberA.length(); i++)
            arrayA[i] = bigNumberA.charAt(bigNumberA.length() - 1 - i) - '0';
        for (int i = 0; i < bigNumberB.length(); i++)
            arrayB[i] = bigNumberB.charAt(bigNumberB.length() - 1 - i) - '0';
        //遍历数组，按位相加
        for (int i = 0; i < result.length; i++) {
            int temp = result[i];
            temp += arrayA[i];
            temp += arrayB[i];
            //判断是否进位
            if (temp >= 10) {
                temp = temp - 10;
                result[i + 1] = 1;
            }
            result[i] = temp;
        }
        //把result数组再次逆序并转成String
        StringBuilder sb = new StringBuilder();
        //是否找到大整数的最高有效位
        boolean findFirst = false;
        for (int i = result.length - 1; i >= 0; i--) {
            if (!findFirst) {
                if (result[i] == 0) continue;
                findFirst = true;
            }
            sb.append(result[i]);
        }
        return sb.toString();
    }
```

# 大数相乘

## 分析

- 也是利用竖式计算，在加法的基础上改造，大体分为两步：
  - 整数B的每一个数位和整数A所有数位依次相乘，得到中间结果
  - 所有中间结果相加，得到最终结果
- 时间复杂度：`O(m*n)`，m、n分别为两个数的位数

---

这样的复杂度有点高，有没有优化的办法呢？
- 可以使用`分治法`，将原本长度为 n 的大整数的 1 次乘积，被转化成了长度为 n/2 的大整数的 4 次乘积，还可以继续细分
- 然后通过数学上的转换，可以将 4 次乘法和 3 次加法，转变成 3 次乘法和 6 次加法
- 最终的时间复杂度经过推导 = `O(n)`
- 不过代码变得比较复杂了，有空研究吧 todo

---

继续优化？
- 使用`快速傅里叶变换`可以使得时间复杂度达到`O(nlogn)`级别
- 具体推导涉及更复杂的数学推导过程
- 看来算法到最后拼的都是math啊


## Java实现

```java
/**
 * 大整数求乘积
 * @param bigNumberA  大整数A
 * @param bigNumberB  大整数B
 */
public static String multiply(String bigNumberA, String bigNumberB) {
    //1.把两个大整数用数组逆序存储，数组长度等于两整数长度之和
    int lengthA = bigNumberA.length();
    int lengthB = bigNumberB.length();
    int[] arrayA = new int[lengthA];
    for(int i=0; i< lengthA; i++){
        arrayA[i] = bigNumberA.charAt(lengthA-1-i) - '0';
    }
    int[] arrayB = new int[lengthB];
    for(int i=0; i< lengthB; i++){
        arrayB[i] = bigNumberB.charAt(lengthB-1-i) - '0';
    }
    //2.构建result数组，数组长度等于两整数长度之和
    int[] result = new int[lengthA+lengthB];
    //3.嵌套循环，整数B的每一位依次和整数A的所有数位相乘，并把结果累加
    for(int i=0;i<lengthB;i++) {
        for(int j=0;j<lengthA;j++) {
            //整数B的某一位和整数A的某一位相乘
            result[i+j] += arrayB[i]*arrayA[j];
            //如果result某一位大于10，则进位，进位数量是该位除以10的商
            if(result[i+j] >= 10){
                result[i+j+1] += result[i+j]/10;
                result[i+j] = result[i+j]%10;
            }
        }
    }
    //4.把result数组再次逆序并转成String
    StringBuilder sb = new StringBuilder();
    //是否找到大整数的最高有效位
    boolean findFirst = false;
    for (int i = result.length - 1; i >= 0; i--) {
        if(!findFirst){
            if(result[i] == 0){
                continue;
            }
            findFirst = true;
        }
        sb.append(result[i]);
    }
    return sb.toString();
}

public static void main(String[] args) {
    String x = "3338429042340042304302404";
    String y = "12303231";
    System.out.println(multiply(x, y));
}
```

# 参考

- [漫画：如何实现大整数相加？（修订版）](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653196069&idx=1&sn=55f0eec8664e82151ed2a6cb371179f8&chksm=8c99fdffbbee74e9d3884026da3756b79db20302b49a69c8c033173d50ee2afded6258f55a4e&scene=21#wechat_redirect)
- [漫画：如何实现大整数相乘？（整合版）](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653196506&idx=2&sn=2a032d5a85bbe5efcc704aaa927598b5&chksm=8c99e200bbee6b16f76d60e7014a1bbf9f76150e0cc149f753b81e76c58209a72d9b10faf2c1&scene=21#wechat_redirect)