---
title: 哈夫曼树与哈夫曼编码
tags:
  - 哈夫曼树
  - 二叉树
categories:
  - 算法与数据结构
cover: >-
  https://images.pexels.com/photos/6424586/pexels-photo-6424586.jpeg?auto=compress&cs=tinysrgb&dpr=2&w=500
abbrlink: ff8e2396
date: 2022-05-21 21:12:59
---


# 如何构造一棵哈夫曼树？

给定一个有序序列，如何构造一棵哈夫曼树？
1. 构建森林：把每一个叶子结点，都当做树一颗独立的树（只有根结点的树）
2. 维护一个`辅助队列`，按照权值从小到大存储了所有叶子结点（以及之后会生成的节点）
3. 选择当前`权值最小的`两个结点，生成新的父结点
4. 从队列中移除上一步选择的两个最小结点，把新的父节点加入队列
5. 重复第3步，当`队列中只有一个节点`时（说明整个森林已经合并成了一颗树），结束

---

该算法的时间复杂度为O(n*logn)

# Java实现
```java
import java.util.PriorityQueue;
import java.util.Queue;

public class HuffmanTree {

    public static void main(String[] args) {
        int[] weights = {2, 3, 7, 9, 18, 25};
        HuffmanTree huffmanTree = new HuffmanTree();
        huffmanTree.createHuffman(weights);
        huffmanTree.output(huffmanTree.root);
    }

    private Node root;

    //构建哈夫曼树
    public void createHuffman(int[] weights) {
        //优先队列，用于辅助构建哈夫曼树
        Queue<Node> nodeQueue = new PriorityQueue<>();
        Node[] nodes = new Node[weights.length];
        //构建森林，初始化nodes数组
        for (int i = 0; i < weights.length; i++) {
            nodes[i] = new Node(weights[i]);
            nodeQueue.add(nodes[i]);
        }
        nodeQueue.forEach(node -> System.out.print(node.weight + " "));
        System.out.println();
        //主循环，当结点队列只剩一个结点时结束
        while (nodeQueue.size() > 1) {
            //从结点队列选择权值最小的两个结点
            Node left = nodeQueue.poll();
            Node right = nodeQueue.poll();
            //创建新结点作为两结点的父节点
            Node parent = new Node(left.weight + right.weight, left, right);
            nodeQueue.add(parent);
        }
        root = nodeQueue.poll();
    }

    //按照前序遍历输出
    public void output(Node head) {
        if (head == null) {
            return;
        }
        System.out.print(head.weight + " ");
        output(head.lChild);
        output(head.rChild);
    }

    public static class Node implements Comparable<Node> {
        int weight;
        Node lChild;
        Node rChild;

        public Node(int weight) {
            this.weight = weight;
        }

        public Node(int weight, Node lChild, Node rChild) {
            this.weight = weight;
            this.lChild = lChild;
            this.rChild = rChild;
        }

        @Override
        public int compareTo(Node o) {
//            return Integer.compare(o.weight, this.weight); // todo
            return Integer.compare(this.weight, o.weight);
        }
    }
}
```

# 哈夫曼树的应用——哈夫曼编码

- 哈夫曼编码是一种不定长编码方式，通过构造哈夫曼树，产生最短前缀编码
- 应用：比如zip压缩文件、jpeg图片格式，可以节省存储空间

# Java实现哈夫曼编码

- 在构造完哈夫曼树后，从根节点进行递归，填充每个节点的编码即可

```java
import java.util.PriorityQueue;
import java.util.Queue;

public class HuffmanCode {

    public static void main(String[] args) {
        char[] chars = {'A', 'B', 'C', 'D', 'E', 'F'};
        int[] weights = {2, 3, 7, 9, 18, 25};
        HuffmanCode huffmanCode = new HuffmanCode();
        huffmanCode.createHuffmanTree(weights);
        huffmanCode.encode(huffmanCode.root, "");
        for (int i = 0; i < chars.length; i++) {
            System.out.println(chars[i] + ":" + huffmanCode.convertHuffmanCode(i));
        }
    }

    private Node root;
    private Node[] nodes;

    //构建哈夫曼树
    public void createHuffmanTree(int[] weights) {
        //优先队列，用于辅助构建哈夫曼树
        Queue<Node> nodeQueue = new PriorityQueue<>();
        nodes = new Node[weights.length];
        //构建森林，初始化nodes数组
        for (int i = 0; i < weights.length; i++) {
            nodes[i] = new Node(weights[i]);
            nodeQueue.add(nodes[i]);
        }
        //主循环，当结点队列只剩一个结点时结束
        while (nodeQueue.size() > 1) {
            //从结点队列选择权值最小的两个结点
            Node left = nodeQueue.poll();
            Node right = nodeQueue.poll();
            //创建新结点作为两结点的父节点
            Node parent = new Node(left.weight + right.weight, left, right);
            nodeQueue.add(parent);
        }
        root = nodeQueue.poll();
    }

    //输入字符下表，输出对应的哈夫曼编码
    public String convertHuffmanCode(int index) {
        return nodes[index].code;
    }

    //用递归的方式，填充各个结点的二进制编码
    public void encode(Node node, String code) {
        if (node == null) {
            return;
        }
        node.code = code;
        encode(node.lChild, node.code + "0");
        encode(node.rChild, node.code + "1");
    }

    public static class Node implements Comparable<Node> {
        int weight;
        String code;//结点对应的二进制编码
        Node lChild;
        Node rChild;

        public Node(int weight) {
            this.weight = weight;
        }

        public Node(int weight, Node lChild, Node rChild) {
            this.weight = weight;
            this.lChild = lChild;
            this.rChild = rChild;
        }

        @Override
        public int compareTo(Node o) {
            return Integer.compare(this.weight, o.weight);
        }
    }
}
```


# 参考

- [漫画：什么是 “哈夫曼树” ？](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653202401&idx=1&sn=319b8d8bf51d3e79d56d212a6b24b2c4&chksm=8c99d53bbbee5c2d24aac1edbbe35e80919ae716637a3897398d26ac9fd0ac0d35ab7ec111d7&scene=21#wechat_redirect)
- [漫画：“哈夫曼编码” 是什么鬼？](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653202633&idx=1&sn=9316701e56b5ac842ca146efdae7827e&chksm=8c99da13bbee53052de481ccabfc2a976f4a106f2ce5181ba01fb388adaf120246d9ff91c416&scene=21#wechat_redirect)