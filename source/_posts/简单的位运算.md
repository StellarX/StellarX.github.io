---
title: 简单的位运算
tags:
  - 位运算
categories:
  - 算法与数据结构
abbrlink: 48a76778
date: 2022-04-12 18:23:03
cover: https://images.pexels.com/photos/1456304/pexels-photo-1456304.jpeg?auto=compress&cs=tinysrgb&dpr=2&w=500
---

# Java实现

```java

/**
 * 简单的位运算练习
 */
public class BitOperation {
    public static void main(String[] args) {
        swap();
        findSingleNum();
        System.out.println(pow(2, 30));
        System.out.println(findN(2147483647L));//2^31 - 1，答案是2^30
    }

    /**
     * 交换两个数 注意这里效率其实不如声明一个临时变量
     */
    public static void swap() {
        int a = 1, b = 2;//注意必须是两个不同的数
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;
        System.out.println(a);
        System.out.println(b);
    }

    /**
     * 给你一组整型数据，这些数据中，其中有一个数a只出现了1次，其他的数都出现了2次，找出a
     */
    public static void findSingleNum() {
        int[] nums = {1, 2, 3, 4, 5, 1, 2, 3, 4};
        int res = nums[0];
        for (int i = 1; i < nums.length; ++i)
            res ^= nums[i];
        System.out.println(res);
    }

    /**
     * 求x的n次幂（快速幂） 时间复杂度：O(logn)
     */
    public static long pow(long x, long n) {
        long res = 1;
        while (n > 0) {
            if ((n & 1) == 1) {
                res *= x;
            }
            n >>= 1;
            x = x * x;
        }
        return res;
    }

    /**
     * 找出不大于N的最大的2的幂指数（参数传入最大只支持2^32 - 1，要更大继续移位即可）
     */
    public static long findN(long n) {
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;//现在最多有32位bit变成1了
        return (n + 1) >> 1;
        /*
         * 我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，
         * 那么得到的结果中第 k+1 位也必定为 1,
         * 然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;
         * 同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,
         * 然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，
         * 如此往复下去….
         * 就能把所有二进制位都变成1
         */
    }
}

```

