---
title: 二叉排序树
tags:
  - 二叉树
  - 二叉排序树
  - 排序
  - 搜索
  - 二分法
categories: 算法与数据结构
abbrlink: e5052ecb
date: 2022-04-20 21:32:03
cover: https://images.pexels.com/photos/11603647/pexels-photo-11603647.jpeg?auto=compress&cs=tinysrgb&dpr=2&w=500
---
# BST的性质
1. 若它的左子树不为空，则左子树上所有结点的值均小于它的父节点的值； 
2. 若它的右子树不为空，则右子树上所有结点的值均大于它的父节点的值；
3. 它的左、右子树也分别为二叉排序树(递归)。
注意：树中的元素是可以重复的，即可以改为大于等于或小于等于。
# BST的特点
- 因为BST的中序序列是一个有序序列，所以对于一个任意的关键字序列构造一颗二叉排序树，实质就是对其进行排序，使其变为有序序列
- 从BST的构造可以看出，任何结点都是作为`叶子`结点插入的 
- 对于同一组关键字集合，若排列顺序不同，本文的算法生成的BST可能不同，查找效率也就因此不同 
- 高度越小的BST，查找效率越高
- 关键字比较的次数不超过树的高度
# 复杂度
- 就维护表的有序性而言，BST更有效，因为无须移动元素，只需修改指针即可完成结点的插入和删除
- 平均执行时间为O（log2n）

# 基本操作Java实现
删除分4种情况：
1. 被删结点没有子树   直接删除 
2. 只有左子树   直接删除，左子树接上 
3. 只有右子树   直接删除，右子树接上 
4. 左右都有     这种最复杂，但也很简单
---
情况4有2种办法：（通常采用第一种） 
1. 找到左子树中的最大结点r，用r替换，再删除r（r肯定是没有右子树，所以删除r采用情况2的办法， 原理是中序前驱替代被删结点） 
2. 第二种当然就是找到右子树中最小的，其他类似
---
另外，删除根节点的话要特殊考虑
```java
package com.space.algorithm.tree;

/**
 * binary search tree
 */
public class Bst {
    static class BSTNode { // this is an internal class
        private int key;
        private BSTNode lc = null;
        private BSTNode rc = null;
    }

    public static void main(String[] args) {
        int[] a = new int[]{2, 3, 54, 1, 5, 0, 5, 3, 2, 1};
        BSTNode b = CreateBST(a);
        DispBST(b);
        InsertBST(b, 7);
        System.out.println();
        DispBST(b);
        System.out.println();
        InOrder(b); //InOrder traversal
        System.out.println();
        System.out.println(searchBstNode(b, 7).key);
        System.out.println(searchBstWithParentNode(b, 54, null).key);
//        2(1(0,1),3(2,54(5(3,5))))
//        2(1(0,1),3(2,54(5(3,5(,7)))))
//        0 1 1 2 2 3 3 5 5 7 54
//        7
//        3
    }

    public static BSTNode CreateBST(int[] a) {
        BSTNode bst = null;
        for (int j : a)
            bst = InsertBST(bst, j);
        return bst;
    }

    public static BSTNode InsertBST(BSTNode b, int k) { // Insert a data in bst
        if (b == null) {
            b = new BSTNode();
            b.key = k;
            b.lc = null;
            b.rc = null;
            return b;
        }
        if (b.key > k) b.lc = InsertBST(b.lc, k);
        else b.rc = InsertBST(b.rc, k);
        return b;
    }

    public static void DispBST(BSTNode bstNode) { //parenthesized notation
        if (bstNode != null) {
            System.out.print(bstNode.key);
            if (bstNode.rc != null || bstNode.lc != null) {
                System.out.print("(");
                DispBST(bstNode.lc);
                if (bstNode.rc != null) System.out.print(",");
                DispBST(bstNode.rc);
                System.out.print(")");
            }
        }
    }

    public static void InOrder(BSTNode bstNode) {//inorder traversal
        if (bstNode != null) {
            InOrder(bstNode.lc);
            System.out.print(bstNode.key + " ");
            InOrder(bstNode.rc);
        }
    }

    public static BSTNode searchBstNode(BSTNode node, int key) {
        if (node != null) {
            if (node.key == key) return node;
            if (node.key > key) return searchBstNode(node.lc, key);
            else return searchBstNode(node.rc, key);
        }
        return null;
    }

    //return the parent node of node
    public static BSTNode searchBstWithParentNode(BSTNode node, int key, BSTNode p) {
        if (node == null || node.key == key) return p;
        if (node.key < key) return searchBstWithParentNode(node.rc, key, node);
        else return searchBstWithParentNode(node.lc, key, node);
    }

    public static void deleteNode(BSTNode node, BSTNode p, int flag, int key) {
        if (node != null) {
            if (node.key == key) delete(node, p, flag);
            if (key < node.key) deleteNode(node.lc, node, 0, key);
            else deleteNode(node.rc, node, 1, key);
        }
    }

    public static void delete(BSTNode node, BSTNode p, int flag) {
        if (node.rc == null) {//这里需要知道b在父节点的左边还是右边，所有才有了0，1之分
            if (flag == -1) del(node.lc, node);//-1表示删除根节点
            else if (flag == 0) p.lc = node.lc;
            else p.rc = node.lc;
        } else if (node.lc == null) {
            if (flag == -1) ;//todo 和del类似，找右子树中最小的节点 del(node.rc, node);
            else if (flag == 0) p.lc = node.rc;
            else p.rc = node.rc;
        } else del(node.lc, node);
    }

    public static void del(BSTNode node, BSTNode p) {
        if (node.lc == null && node.rc == null) {//except：左子树只有一个节点
            p.key = node.key;
            p.lc = null;
            return;
        }
        if (node.rc == null) {// except: 左子树的根节点没有右子树，那么根节点就是最大值
            p.key = node.key;
            p.lc = node.lc;
            return;
        }
        BSTNode t = node;
        BSTNode p_temp = p;
        while (t.rc != null) {
            p_temp = t;
            t = t.rc;
        }
        p.key = t.key;
        p_temp.rc = t.lc;//父节点的右指针指向被删除节点的左孩子，若没有则为null
    }
}

```
# C++实现的完整代码
- C++快忘了，有时间来看看 todo
```c++
typedef int keytype;
typedef struct node{
	keytype key;
	node *lc, *rc;   // 注意这里不能写BSTNode  待记忆
}BSTNode;

//创建BST（参数为二级指针，不推荐）
bool InsertBST(BSTNode **bt, keytype k){//bt must be reference type or second rank pointer
    	if(*bt == NULL){//allow insert
    		*bt = (BSTNode *)malloc(sizeof(BSTNode));
    		(*bt)->key = k;
    		(*bt)->lc = (*bt)->rc = NULL; 	
    		return true;
    	}
    	if((*bt)->key == k) return false;
    	if(k < (*bt)->key) return InsertBST(&(*bt)->lc, k);//这里要取地址，不然报错，因为形参是二级指针
	else return InsertBST(&(*bt)->rc, k);//&((*bt)->rc) 这样写更易理解
}

BSTNode *CreateBST(int a[], int n){
	BSTNode *bt = NULL;
	for(int i = 0; i < n; i++)
		InsertBST(&bt, a[i]);//apparently bt will be changed
	return bt;//return the changed bt
}

//创建BST （参数为引用，推荐）
bool InsertBST(BSTNode *&bt, keytype k){//bt must be reference type or second rank pointer
	if(bt == NULL){//allow insert
		bt = (BSTNode *)malloc(sizeof(BSTNode));
		bt->key = k;
		bt->lc = bt->rc = NULL; 	
		return true;
	}
	if(bt->key == k) return false;
	if(k < bt->key) return InsertBST(bt->lc, k);
	else return InsertBST(bt->rc, k);
}

BSTNode *CreateBST(int a[], int n){
	BSTNode *bt = NULL;//
	for(int i = 0; i < n; i++)
		InsertBST(bt, a[i]);//apparently bt will be changed
	return bt;//return the changed bt
}

void DestroyBST(BSTnode *&bt) {//
	if (bt != NULL) {
		DestroyBST(bt->lc);
		DestroyBST(bt->rc);
		free(bt);
		bt = NULL;//注意要把bt置为NULL，因为free只释放了bt指向的内存
	}
}

void DispBST(BSTNode *bt){// output in parenthesized notation//括号表示法 
	if(bt != NULL){
		cout << bt->key;
		if(bt->lc != NULL || bt->rc != NULL){
			cout << "(";
			DispBST(bt->lc);
			if(bt->rc != NULL) cout << ",";
			DispBST(bt->rc);
			cout << ")";
		}
	}
}

//递归输出搜索路径（逆序，不管成功与否）
void SearchPath(BSTNode *bt, keytype k) {
	if (bt == NULL) {
		cout << "no such key..." << endl;
		return;
	}
	if (bt->key == k) {
		cout << k << " ";
		return;
	}
	if (bt->key > k) SearchPath(bt->lc, k);
	else SearchPath(bt->rc, k);
	cout << bt->key << " ";
}

//非递归输出搜索路径
void SearchPath2(BSTnode *bt, keytype k, keytype path[], int i) {
	if (bt == NULL) return;
	else if (k == bt->key) {
		path[i + 1] = bt->key;
		for (int j = 0; j <= i + 1; j++)
			cout << path[j] << " ";
		cout << endl;
	}
	else {
		path[i + 1] = bt->key;
		if (k < bt->key)
			SearchPath2(bt->lc, k, path, i + 1);
		else
			SearchPath2(bt->rc, k, path, i + 1);
	}
}

BSTNode *SearchBST(BSTNode *bt, keytype k){//查找
	if(bt == NULL || bt->key == k) return bt;
	if(k < bt->key) return SearchBST(bt->lc, k);
	else return SearchBST(bt->rc, k);
} 

BSTNode *SearchBST_WithParentNode(BSTNode *bt, keytype k, BSTNode *f) {//查找，包括双亲结点
	if (bt == NULL) {
		f = NULL;
		return NULL;
	}
	if (bt->key == k) {
		return f;
	}
	if (bt->key > k) return SearchBST_WithParentNode(bt->lc, k, bt);
	else return SearchBST_WithParentNode(bt->rc, k, bt);
}
int main() {
	
	BSTNode *bt;
	//int path[100];
	keytype k = 6;//search term is 6
	int a[] = {4,9,0,1,8,6,3,5,2,7};
	int n = 10;
	
	cout << "1. Create a binary search tree..." << endl;
	bt = CreateBST(a, n);
	
	cout << "2. Display BST:  ";
	DispBST(bt);
	cout << endl;
	
	cout << "3. Search a key term...(2 ways)  ";
    if(SearchBST(bt, k) != NULL)
		cout << SearchBST(bt, k)->key << endl;
	else cout << "no such key";
 
    BSTNode *f = NULL;
	f = SearchBST_WithParentNode(bt, k, f);
	if(f != NULL) cout << f->key << endl;//output parent node
	else cout << "no parent node!" << endl;
	return 0; 
}

```
运行结果
1. Create a binary search tree...
2. Display BST:  4(0(,1(,3(2))),9(8(6(5,7))))
3. Search a key term...  6