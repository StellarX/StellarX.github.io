---
title: 图的广度优先搜索
date: 2022-05-02 12:45:44
tags:
- bfs
---

# C++
```c++
int maxsize = 100;

void BFS(AdjGraph *G, int v){
	int visit[MAXV] = {0};
	int queue[MAXV], front = 0, rear = 0;
	visit[v] = 1; cout << v << " ";
	rear = (rear + 1) % maxsize;
	queue[rear] = v;
	while(front != rear){
		front = (front + 1) % maxsize;
		int tmp = queue[front];
		ArcNode *p = G->adjlist[tmp].firstarc;
		while(p != NULL){
			if(visit[p->no] == 0){
				cout << p->no << " ";
				visit[p->no] = 1;
				rear = (rear + 1) % maxsize;
				queue[rear] = p->no;
			}
			p = p->nextarc;
		}
	}
}
```
# Java
```java
public static void bfs(Graph graph, int v) {
    int[] visited = new int[graph.n];
    int[] queue = new int[graph.n];
    int front = 0, rear = 0;
    visited[v] = 1;
    System.out.print(v + " ");
    rear = (rear + 1) % graph.n;
    queue[rear] = v;
    while (front != rear) {
        front = (front + 1) % graph.n;
        int t = queue[front];
        ArcNode arcNode = graph.adjList.get(t).firstArc;
        while (arcNode != null) {
            if (visited[arcNode.no] == 0) {
                visited[arcNode.no] = 1;
                System.out.print(arcNode.no + " ");
                rear = (rear + 1) % graph.n;
                queue[rear] = arcNode.no;
            }
            arcNode = arcNode.nextArc;
        }
    }
}
```
