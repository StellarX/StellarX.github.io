---
title: 二叉堆及其应用
tags:
  - 二叉堆
  - 优先队列
  - 二叉树
categories:
  - 算法与数据结构
cover: 'https://images.pexels.com/photos/2150/sky-space-dark-galaxy.jpg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260'
abbrlink: 3d9382cc
date: 2022-04-06 19:05:30
---

# 二叉堆

- 二叉堆的根节点叫作`堆顶`
- 二叉堆本质上是一种完全二叉树，它分为两个类型。
  1. `最大堆`。最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值
  2. `最小堆`。最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值
- 构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次“下沉”。从`最后一个非叶子节点`开始。
- 当二叉堆插入节点时，插入位置是`完全二叉树的最后一个位置`
- 二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于`堆顶`的节点。这时，为了继续维持完全二叉树的结构，我们把`堆的最后一个节点`临时补到原本堆顶的位置，然后让这个节点做下沉操作

## Java实现

```java
public class BinaryHeap {
    public static void main(String[] args) {
        int[] array = new int[]{1, 3, 2, 6, 5, 7, 8, 9, 10, 0};
        upAdjust(array);
        System.out.println(Arrays.toString(array));

        array = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        buildHeap(array);
        System.out.println(Arrays.toString(array));
    }

    /**
     * 构建堆 以最小堆为例
     * @param array 待调整的堆
     */
    public static void buildHeap(int[] array) {
        // 从最后一个非叶子节点开始，依次做“下沉”调整
        for (int i = (array.length / 2) - 1; i >= 0; i--)
            downAdjust(array, i, array.length);
    }

    /**
     * “下沉”调整
     *
     * @param array       待调整的堆
     * @param parentIndex 要“下沉”的父节点
     * @param length      堆的有效大小
     */
    public static void downAdjust(int[] array, int parentIndex, int length) {
        // temp 保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while (childIndex < length) {
            // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子
            if (childIndex + 1 < length && array[childIndex + 1] < array[childIndex])
                childIndex++;
            // 如果父节点小于任何一个孩子的值，则直接跳出
            if (temp <= array[childIndex]) break;
            //无须真正交换，单向赋值即可
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * childIndex + 1;
        }
        array[parentIndex] = temp;
    }

    /**
     * “上浮”调整
     * 将完全二叉树最后一个节点在二叉堆中上浮
     * @param array 待调整的堆
     */
    public static void upAdjust(int[] array) {
        int childIndex = array.length - 1;
        int parentIndex = (childIndex - 1) / 2;
        // temp 保存插入的叶子节点值，用于最后的赋值
        int temp = array[childIndex];
        while (childIndex > 0 && temp < array[parentIndex]) {
            //无须真正交换，单向赋值即可
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;
    }
}
```
- 代码中有一个优化的点，就是在父节点和孩子节点做连续交换时，并不一定要真的交换，只需要先把交换一方的值存入temp变量，做单向覆盖，循环结束后，再把temp的值存入交换后的最终位置即可

## 复杂度分析

- 堆的插入和删除操作，时间复杂度是O(logn)
- 构建堆的时间复杂度并不是O(nlogn)，而是O(n)。这涉及数学推导过程

# 二叉堆的应用

## 优先队列

- 优先队列不再遵循先入先出的原则，而是分为两种情况。
  - 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队
  - 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队
- 可以用最小堆来实现最小优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。

### 算法分析

- 二叉堆节点“上浮”和“下沉”的时间复杂度都是O(logn)，所以优先队列入队和出队的时间复杂度也是O(logn)

### Java实现

```java
/**
 * 最小优先队列，实现原理：二叉堆（最小堆）
 */
public class PriorityQueueImplByHeap {
    private int[] array;
    private int size;
    public PriorityQueueImplByHeap(){
        //队列初始长度为32
        array = new int[32];
        size = 0;
    }

    /**
     * 入队
     * @param key 入队元素
     */
    public void enQueue(int key){
        //队列长度超出范围，扩容
        if(size >= array.length) {
            resize();
        }
        array[size++] = key;
        upAdjust();
    }

    /**
     * 出队
     * @return 出队元素
     */
    public int deQueue() throws Exception {
        if (size <= 0)
            throw new Exception("the queue is empty!");
        //获取堆顶元素
        int head = array[0];
        //让最后一个元素移动到堆顶
        array[0] = array[--size];
        downAdjust();
        return head;
    }

    public void upAdjust() {
        int childIndex = size - 1;
        int parentIndex = (childIndex - 1) / 2;
        // temp 保存插入的叶子节点值，用于最后的赋值
        int temp = array[childIndex];
        while (childIndex > 0 && temp < array[parentIndex]) {
            //无须真正交换，单向赋值即可
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;
    }

    public void downAdjust() {
        // temp 保存父节点值，用于最后的赋值
        int parentIndex = 0;
        int temp = array[parentIndex];
        int childIndex = 1;
        while (childIndex < size) {
            // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子
            if (childIndex + 1 < size && array[childIndex + 1] < array[childIndex])
                childIndex++;
            // 如果父节点小于任何一个孩子的值，则直接跳出
            if (temp <= array[childIndex]) break;
            //无须真正交换，单向赋值即可
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * childIndex + 1;
        }
        array[parentIndex] = temp;
    }

    public void resize(){
        int newSize = this.size * 2;
        this.array = Arrays.copyOf(this.array, newSize);
    }


    public static void main(String[] args) throws Exception {
        PriorityQueueImplByHeap priorityQueueImplByHeap = new PriorityQueueImplByHeap();
        priorityQueueImplByHeap.enQueue(3);
        priorityQueueImplByHeap.enQueue(7);
        priorityQueueImplByHeap.enQueue(1);
        priorityQueueImplByHeap.enQueue(4);
        System.out.println(priorityQueueImplByHeap.deQueue());
        System.out.println(priorityQueueImplByHeap.deQueue());
        System.out.println(priorityQueueImplByHeap.deQueue());
        System.out.println(priorityQueueImplByHeap.deQueue());
//        priorityQueueImplByHeap.deQueue();
    }
}
```

### 相关文章

-  [Java中PriorityQueue的用法和底层实现原理](https://blog.csdn.net/u010623927/article/details/87179364)

